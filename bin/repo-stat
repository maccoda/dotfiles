#!/usr/local/bin/fish
# Usage repo-stat [-y] <directory>
#
# -y: If set will not require user input and will always pull updates
# <directory>: Directory to start searching for .git directories from
#

argparse 'y' -- $argv

set startDir $argv[1]
test -z $startDir; and set startDir (realpath '.')
echo "Starting at $startDir"
if set -q _flag_y
    echo "Will automatically fetch and pull from origin"
end

echo -n "Fetching updates for "
set dirs (fd --hidden --no-ignore --type directory '.git$' $startDir)
for dir in $dirs
    set -l repoDir (echo $dir | sed "s/\/.git//")
    set -l short_name (basename $repoDir)
    echo -n "$short_name "
    cd $repoDir
    git fetch -q &
    cd - > /dev/null
end

echo
wait

for dir in $dirs
    set -l repoDir (echo $dir | sed 's/\/.git//')
    cd $repoDir
    set -l short_name (basename $repoDir)

    set -l git_status (git status --porcelain &)
    set -l commits (git log origin/mainline..mainline 2> /dev/null | grep '^commit' | wc -l | tr -d " " &)
    set -l commits_behind (git log mainline..origin/mainline 2> /dev/null | grep '^commit' | wc -l | tr -d " " &)

    wait

    if test -n "$git_status"
        echo "$short_name is dirty"
    end

    if test $commits -gt 0
        echo "$short_name is ahead of origin"
    end

    if test $commits_behind -gt 0
        echo "$short_name is behind origin"
        if set -q _flag_y
            gpr
        else
            read -P "Would you like to pull updates? (y/n) " input
            switch $input
                case Y y
                    gpr
                case '*'
                    echo "Leaving $short_name behind origin"
            end
        end
    end
    cd - > /dev/null
end
